'''
Модуль bisect - обеспечивает поддержку списка в отсортированном порядке с помощью алгоритма деления пополам.

Набор функций:
bisect.insort(list, elem), он же bisect.insort_right(list, elem) - вставка элемента в отсортированный список, при этом elem располагается как можно правее (все элементы, равные ему, остаются слева).
bisect.insort_left(list, elem) - вставка элемента в отсортированный список, при этом elem располагается как можно левее (все элементы, равные ему, остаются справа).
bisect.bisect(list, elem), он же bisect.bisect_right(list, elem) - поиск места для вставки элемента в отсортированный список, таким образом, чтобы elem располагался как можно правее.
bisect.bisect_left(list, elem) - поиск места для вставки элемента в отсортированный список, таким образом, чтобы elem располагался как можно левее.
'''

import bisect
'''Выполняет поиск элемента в отсортированном списке. Именно в отсортированном.'''

file = open('C:\word.txt')
lis = []
for el in file:
    el = el.replace('\n', '')
    lis.append(el)
'''Открывает файл и превращает его в список, убрав переносы строки (в файле много слов, каждое слово с новой строки).'''


def search(lis, word):
    '''Принимает список и слово, которое надо найти.
    1. Переменная index показывает место в списке, справа от искомого слова (т.е. +1). Так происходит, потому что
    bisect ищет место, в которое заданное слово надо поставить, чтобы сохранить отсортированность списка.
    Он принимает слово, например hello, ищет место, куда его поставить, и место получается правее другого слова hello,
    которе уже есть в списке. Т.е. он находи слово hello и предлагает поставить другое слово hello правее на 1.
    2. if получает индекс (куда поставить слово), и проверяет, чтобы на предыдущем месте было искомое слово.
    3. Если слово на месте, то отдается текст, мол "нашлось ваше слово, оно тут..."
    4. Если слова нет (по индексу стоит другое слово, а не переданное в функцию), то выдает другой текст.
    Почему там другое слово – потому что bisect просто находит место, куда можно поставить переданное ему слово,
    его не интересует, содержится ли это слово в списке, он просто ищет подходящее место.
    Так что может так получится, что bisect нашел место для заданного слова hello, которое будет сразу после hell.'''
    index = bisect.bisect(lis, word)
    if lis[index - 1] == word:
        return f'Слово {word} находится в списке по идкесу {index - 1}\n' \
               f'Убедитесь сами, вызвав элемент с таким индексом:\n' \
               f'print(lis[{index - 1}]) – это надо скопипастить'
    else:
        return f'Слово {word} отсутствует в списке'


print(search(lis, 'hello'))
print(lis[45100])