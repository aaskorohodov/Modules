'''
pytest надо установить и настроить под него конфигурацию, если она не настроится сама.
Функции для проверки можно писать как обычно, руками передавая параметры. А можно через декоратор:

@pytest.mark.parametrize('a, b, result', rtg)
def test_div_good(a, b, result):
    assert division(a, b) == result

! Имена тестов должны начинаться с test_, как в unittest !

Тут a, b = то, что передадим в функцию, result = ожидаемые результат. ! Оно все передается как строка !
rtg = список кортежей, где каждый кортеж содержит a, b, result. Декоратор вызовет новый тест для каждого кортежа.


Для отлова исключений (если хочется тестом вызывать исключение в проверяемой функции и чтобы тест при этом говорил Ок)
можно использовать менеджер контекста:

@pytest.mark.parametrize('a, b, error', [
    (10, 0, ZeroDivisionError),
    (10, '2', TypeError)
])
def test_div_zero(a, b, error):
    with pytest.raises(error):
        division(a, b)

Тут нам не важно, что будет в результате работы проверяемой функции, так как мы ожидаем получить ошибку раньше, чем
она отработает. Поэтому в теле with просто передаем параметры в функции и ничего не ждем в результате. Передать разные
ошибки можно тоже списком кортежей.


Если хочется запускать конкретный тест, а не все из файла, то можно указать его название (название функции), в настройках
конфигурации (script path), указав не только имя файла, но и имя теста через :: (...tests.py::test_1)
'''