'''
Общие положения

1. Лучше много мелких коммитов, чем 1 большой
    1.1 Если накопилось изменений, то их можно комитить не все сразу, а кусками, каждый со своим сообщением
2. Прописывать сообщение коммита понятным языком
3. Перед коммитом просматривать все изменения, на случай, если там что-то отладочно-проверочное
4. Если кусок кода больше не нужен – бесстрашно удалять (он останется в VC)
5. Не надо лезть в консоль, когда все уже есть в IDE

3 уровня конфигурации (git config):
– покрывает всех пользователей --system
– конкретный пользователь системы --global
– текущий репозиторий --local

Задать имя пользователя и почту:
1. git config --global user.name "Arkady"
2. git config --global user.email "a@gmail.com"
Чтобы посмотреть текущее имя/почту – git config --global user.name/email

Удобнее работать в BASH, вызывается правым кликом на нужную папку.
Каталог (папка) создается системно или mkdir.
Создание репозитория: git init
*репозиторий отличается от папки проекта – репозиторий это папка .git внутри проекта. Там будут сами файлы git

Создать .gitignore, туда положить /venv/ и /.idea/ – idea несет настройки, которые могут все поломать качающему


BASH

BASH = Bourne Again Shell – командная строка, идущая вместе с GIT. Также присутствует в UNIX и Mac

Команды:
ls -la – показывает скрытые файлы и папки
touch +имя файла – создает файл
git log – показывает лог
    git log -p – более подробный вывод
git status – текущий статус проекта
git add +имя – добавить в отслеживание. Можно добавлять файлы или папки
git commit -m "сообщение коммита" – коммит
    git commit -ma '' – взять все файлы, который уже есть в версионном контроле, и сразу закоммитить (без git add)
git show + хэш коммита – детально покажет, что было в коммите
vim +имя файла – открывает файл в BASH.
    Можно сразу создать и открыть файл – vim name.txt
    Чтобы выйти ESC, затем :x (двоеточие и икс, с клавиатуры), ENTr
    :x – сохранить и выйти
    :w – выйти и не сохранять
    :q – выйти, если ничего не поменяли
    Чтобы редактировать файл в vim, жмем 'a', пишем, потом ESC, :x
git restore +имя файла – откатить файл к последнему коммиту
git diff – показывает, какие изменения были внесены, с последнего коммита
    git diff +имя файла
    git diff --stage – выведет изменения, которы уже в индексе (подготовлены для коммита, прошли git add)
git mv +имя файла +новое имя файла (с учетом индекса(py/txt/exe...)
    можно перемещать файлы, причем одновременно с переименованием: git mv +имя +/папка/папка/новое имя
    git mv также делает git add автоматом
git rm +имя файла – удалить имя файла
    git rm --cached +имя файла – удаляет файл из VC, но файл физически остается

Ветки

По договоренности – в master лежит протестированный и рабочий код. HEAD указывает на текущий коммит.
git branch +имя ветки – создает новую ветку
git checkout +имя уже созданной ветки – переключение на ветку
    можно передать хэш коммита тогда текущее состояние файлов откатится (или прикатится (вперед)) к этому коммиту
    можно сразу содать ветку – git checkout -b +имя новой ветки
    можно сразу создать ветку и перейти на нее, при том из какого-то другого коммита – git checkout -b +имяветки +хэшветки
git branch -a – покажет все ветки
    git branch -d +имя ветки – удаляет ветку
        *если ветка не merged, то надо использовать git branch -D
git merge +имя ветки – слияние веток
    *если возможен Fast Foward, то GIT просто передвинет указатель master вперед. Это возможно, если сливается ветка,
    являющаяся прямым потомком master.
git reset --hard +хэш коммита – вернет все к указанному коммиту, в том числе отменит индексированние

Сервер

git remote add +имя репозитория +shh с github (если репозиторий был уже был создать на github)
    подключается к удаленному серверу.
    *обычно имя задают как origin, это имя по умолчанию в PyCharm, такая почти договоренность
    *имя репозитория может быть любым, это не то имя, которое было придумано на GitHub
git remote -v – посмотреть репозитории
    fetch – репозитории для чтения
    push – для записи

git push +имя репозитория (куда класть) +ветка назначения (в какую ветку класть) (master, например)
    *тут имя репозитория указывается тем, которые было выбрано в предыдущей команде, когда сервер подключался
    *если указать другое имя репозитория назначения, то вылетит ошибка

git fetch origin (или другое имя) – перемещает указатель слежения сервера (который находится локально, это доп метка)
    *при этом недостающие коммиты будут скачаны локально, однако указатель master (локально) останется на том же месте,
    но коммиты можно посмотреть (если они были добавлены на сервер кем-то, но посмотреть локально, так как они
    только что были скачаны)
    Затем можно выполнить merge

git clone +ссылка – клонирует репозиторий на локальный ПК
    *сначала нужно выбрать папку, куда это все будет клонировано

git pull origin master – забирает изменения с сервера
'''